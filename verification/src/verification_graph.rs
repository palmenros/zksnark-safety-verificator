use crate::{
    print_verification_graph, ComponentIndex, ConstraintIndex, InputDataContextView, SignalIndex,
};
use circom_algebra::algebra::{ArithmeticExpression, Constraint, Substitution};
use circom_algebra::constraint_storage::ConstraintStorage;
use num_traits::Zero;
use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};
use std::path::Path;
use graphviz_rust::attributes::constraint;
use crate::verification_graph::Node::SubComponentInputSignal;

#[allow(clippy::enum_variant_names)]
#[derive(Clone)]
pub enum Node {
    InputSignal,
    OutputSignal,
    IntermediateSignal,

    SubComponentInputSignal(ComponentIndex),
    SubComponentOutputSignal(ComponentIndex),
}

#[derive(Clone)]
pub struct SafeAssignment {
    // Signal index of the signal appearing in the LHS of the '<==' assignment
    pub lhs_signal: SignalIndex,

    // Signal indices of the signals appearing in the RHS of the '==>' assignment
    pub rhs_signals: BTreeSet<SignalIndex>,

    // Constraint index of the constraint associated to the safe assignment
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A constraint of the type '===' that has not been generated by a safe assignment '<=='
//  TODO: Look for a better name?

#[derive(Clone)]
pub struct UnsafeConstraint {
    // List of *all* participating signals in this constraint, including the key of edge_constraints
    pub signals: BTreeSet<SignalIndex>,

    // Constraint index
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A subcomponent, which has input_signals and output_signals
pub struct SubComponent {
    // input_signals and output_signals are the current inputs and outputs of this component, after
    // possibly removing some nodes by fixed_nodes propagation.
    pub input_signals: BTreeSet<SignalIndex>,
    pub output_signals: BTreeSet<SignalIndex>,

    // original_input_signals and original_output_signals are the original input and output signals
    // of the component, before propagating and possibly removing inputs and outputs
    // TODO: Do we need to store these?
    pub original_input_signals: BTreeSet<SignalIndex>,
    pub original_output_signals: BTreeSet<SignalIndex>,
}

pub type SafeAssignmentIndex = usize;
pub type UnsafeConstraintIndex = usize;

// NOTE: For reproducibility, I have declared the HashMaps as BTreeMap, so they are ordered.
//      Explore whether it's a good idea to change them to HashMap
pub struct VerificationGraph {
    // List of nodes in the graph. Each signal has a node, and it can be of multiple types
    pub nodes: BTreeMap<SignalIndex, Node>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the LHS of the assignment
    pub incoming_safe_assignments: BTreeMap<SignalIndex, SafeAssignmentIndex>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the RHS of the assignment
    pub outgoing_safe_assignments: BTreeMap<SignalIndex, BTreeSet<SafeAssignmentIndex>>,

    // Given a node, it returns the list of all constraints '===' that are not a result of safe
    //    assignments '<==' in which this signal appears
    pub edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>>,

    // Given a component index, it returns the SubComponent struct
    pub subcomponents: BTreeMap<ComponentIndex, SubComponent>,

    // List of all safe_assignments (<==). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub safe_assignments: Vec<SafeAssignment>,

    // List of all unsafe_constraints (===). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub unsafe_constraints: Vec<UnsafeConstraint>,

    //  List of nodes that have been fixed (proved to be unique) but not yet removed from the graph
    pub fixed_nodes: BTreeSet<SignalIndex>,

    // Number of outputs that have not yet been fixed
    pub number_of_outputs_not_yet_fixed: usize,

    // List of subcomponents to verify in order for this component to be verified.
    pub sub_components_to_verify: Vec<ComponentIndex>,
}

struct ConnectedComponent {
    nodes: BTreeSet<SignalIndex>,
}

// This structure represents a polynomial system of constraints that should have their output fixed
pub struct PolynomialSystemFixedSignal {
    constraints: Vec<Constraint<usize>>,

    // Signals to fix from the constraints given above
    signals_to_fix: BTreeSet<SignalIndex>,
}

impl VerificationGraph {
    pub fn new(
        context: &InputDataContextView,
        constraint_storage: &ConstraintStorage,
    ) -> VerificationGraph {
        let tree_constraints = context.tree_constraints;

        let mut nodes = BTreeMap::<SignalIndex, Node>::new();
        let mut subcomponents = BTreeMap::<ComponentIndex, SubComponent>::new();

        // Outputs
        for idx in 0..tree_constraints.number_outputs {
            let s = idx + tree_constraints.initial_signal;
            nodes.insert(s, Node::OutputSignal);
        }

        let mut input_signals = BTreeSet::new();

        // Inputs
        for idx in 0..tree_constraints.number_inputs {
            let s = idx + tree_constraints.number_outputs + tree_constraints.initial_signal;
            nodes.insert(s, Node::InputSignal);
            input_signals.insert(s);
        }

        // Intermediates
        let number_intermediates = tree_constraints.number_signals
            - tree_constraints.number_outputs
            - tree_constraints.number_inputs;

        for idx in 0..number_intermediates {
            let s = idx
                + tree_constraints.number_outputs
                + tree_constraints.number_inputs
                + tree_constraints.initial_signal;

            nodes.insert(s, Node::IntermediateSignal);
        }

        // Components

        // TODO: We should make a difference between safe and unsafe subcomponents. By default, we will
        //  assume that all subcomponents ought to be safe (that is, their output must remain fixed
        //  if the input is fixed). We should allow "unsafe" subcomponents (such as Inverse), which might
        //  not fully determine their outputs when their inputs are fixed. In that case, we should "extract"
        //  the subcomponent signals, constraints and subcomponents into the parent component, so
        //  we can perform the algorithm taking the relationships into account, not as a black box.
        //      This information about unsafe components should be passed by an input .json

        for (cmp_index, c) in tree_constraints.subcomponents.iter().enumerate() {
            let mut subcomponent_inputs = BTreeSet::new();
            let mut subcomponent_outputs = BTreeSet::new();

            // Subcomponent inputs
            for idx in 0..c.number_inputs {
                let s = idx + c.number_outputs + c.initial_signal;
                subcomponent_inputs.insert(s);
                nodes.insert(s, Node::SubComponentInputSignal(cmp_index));
            }

            for idx in 0..c.number_outputs {
                let s = idx + c.initial_signal;
                subcomponent_outputs.insert(s);

                nodes.insert(s, Node::SubComponentOutputSignal(cmp_index));
            }

            subcomponents.insert(
                cmp_index,
                SubComponent {
                    input_signals: subcomponent_inputs.clone(),
                    output_signals: subcomponent_outputs.clone(),
                    original_input_signals: subcomponent_inputs,
                    original_output_signals: subcomponent_outputs,
                },
            );
        }

        let mut incoming_safe_assignments = BTreeMap::<SignalIndex, SafeAssignmentIndex>::new();
        let mut outgoing_safe_assignments =
            BTreeMap::<SignalIndex, BTreeSet<SafeAssignmentIndex>>::new();
        let mut safe_assignments = vec![];

        let mut is_constraint_double_arrow = BTreeSet::new();

        // Add safe assignment edges
        for (constraint, lhs_signal) in &tree_constraints.are_double_arrow {
            is_constraint_double_arrow.insert(*constraint);

            let mut signals: BTreeSet<SignalIndex> = constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_cloned_signals_ordered();
            signals.remove(lhs_signal);

            let safe_assignment = SafeAssignment {
                lhs_signal: *lhs_signal,
                rhs_signals: signals,
                associated_constraint: *constraint,
                active: true,
            };

            let safe_assignment_idx = safe_assignments.len();
            safe_assignments.push(safe_assignment);

            incoming_safe_assignments.insert(*lhs_signal, safe_assignment_idx);

            // Outgoings
            for rhs_signal in constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_signals()
            {
                if rhs_signal != lhs_signal {
                    outgoing_safe_assignments
                        .entry(*rhs_signal)
                        .or_insert(BTreeSet::new())
                        .insert(safe_assignment_idx);
                }
            }
        }

        let mut edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>> =
            BTreeMap::new();
        let mut unsafe_constraints: Vec<UnsafeConstraint> = vec![];

        // Add unsafe edges
        let constraints_range = tree_constraints.initial_constraint
            ..(tree_constraints.initial_constraint + tree_constraints.no_constraints);
        for (constraint_index, c) in constraints_range
            .filter(|idx| !is_constraint_double_arrow.contains(idx))
            .map(|x| (x, constraint_storage.read_constraint(x).unwrap()))
        {
            let signals = c.take_cloned_signals_ordered();

            let unsafe_constraint_index = unsafe_constraints.len();

            for &signal in &signals {
                // let vector: BTreeSet<SignalIndex> = signals.iter().filter(|x| **x != signal).copied().collect();
                edge_constraints
                    .entry(signal)
                    .or_insert(BTreeSet::new())
                    .insert(unsafe_constraint_index);
            }

            unsafe_constraints.push(UnsafeConstraint {
                signals,
                associated_constraint: constraint_index,
                active: true,
            });
        }

        // Compute initial fixed_nodes, which should include the inputs, safe assignments of only constants
        //  (for example, i <== 2) and linear constraints with only one appearing signal and non-zero coefficient
        //  (for example, 3*s===1).
        // TODO: Maybe there are more fixed_nodes initial situations to take into account?

        // Input signals
        let mut fixed_nodes = BTreeSet::new();
        fixed_nodes.append(&mut input_signals);

        // TODO: Find if we need to remove the initial fixed_node from any more data structures.
        //  Check the soundness of this initial fixed_nodes assignation

        // Safe assignments of only constants
        for ass in &mut safe_assignments {
            propagate_fixed_node_in_safe_assignment(
                &mut fixed_nodes,
                ass,
                &mut incoming_safe_assignments,
            );
        }

        // Unsafe constraints ===
        for unsafe_constraint in &mut unsafe_constraints {
            propagate_fixed_node_in_unsafe_constraint(
                constraint_storage,
                &mut fixed_nodes,
                unsafe_constraint,
            );
        }

        VerificationGraph {
            nodes,
            incoming_safe_assignments,
            outgoing_safe_assignments,
            edge_constraints,
            subcomponents,
            safe_assignments,
            unsafe_constraints,
            fixed_nodes,
            number_of_outputs_not_yet_fixed: tree_constraints.number_outputs,
            sub_components_to_verify: vec![],
        }
    }

    pub fn verify(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        // TODO: Maybe there are some easy. common, special cases to consider before executing
        //          the full algorithm.

        // TODO: Return a tree of VerificationOutputs if everything has been verified.
        //      The tree should contain for each component the list of subcomponents that need to
        //      be verified and contain a list of Groebner Basis systems to be solved in addition
        //      to all subcomponents for that component to be verified

        loop {
            self.propagate_fixed_nodes(context, constraint_storage);

            if self.number_of_outputs_not_yet_fixed == 0 {
                // Verification complete, next subcomponents
                // TODO: Record list of subcomponents to verify in some sort of tree structure
                //  and return it
                println!("Complete");
                return;
            }

            // TODO: If there are no === constraints remaining, then the unfixed outputs will remain unfixed

            let is_there_any_unsafe_constraint_remaining =
                self.edge_constraints.iter().any(|(_, set)| !set.is_empty());

            if !is_there_any_unsafe_constraint_remaining {
                let unsafe_outputs = self
                    .nodes
                    .iter()
                    .filter(|(_, n)| matches!(n, Node::OutputSignal))
                    .map(|(signal_index, _)| signal_index);

                for signal_index in unsafe_outputs {
                    println!(
                        "Output '{}' of component '{}', template '{}' is never fixed from inputs!",
                        context.signal_name_map[signal_index],
                        context.tree_constraints.component_name,
                        context.tree_constraints.template_name
                    );
                }
                // TODO: Format the unsafe outputs correctly
                println!("Unsafe!");

                return;
            }

            // TODO: Else, if there are === constraints remaining, we should merge all === constraint
            //  cycles until there are no more connected components that can be merged
            let did_merge = self.merge_unsafe_constraints_connected_component(context, constraint_storage);
            if !did_merge {
                // There is some cyclic dependencies between the different === constraints connected
                //  components, abort

                // TODO: Maybe use some heuristic to make a bigger connected component?
                println!("Cannot determine, cyclic dependencies between === constraints");
                return;
            }
        }
    }

    // This function looks for a connected of === constraints that can be reduced using Groebner
    //  bases. Returns true if it has been able to merge such a connected component, false otherwise
    fn merge_unsafe_constraints_connected_component(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &ConstraintStorage,
    ) -> bool {
        // TODO: Look for a connected component of === that does not have any incoming directed constraint
        //  (that is, <== or component constraint) from a signal outside the connected component.
        //  If we cannot find such a connected component, return False. If we find such a connected
        //  component, determine what are the outputs of the connected component, compute the constraints
        //  (including <== constraints inside the connected component), simplify the constraints using
        //  Gauss-Jordan. If the system is linear, directly output a result. If not, generate a struct
        //  to be solved using Groebner basis.

        // TODO: 1. Compute connected components of === constraints
        // TODO: How do we handle components inputs / outputs
        let connected_components = self.compute_connected_components_unsafe_constraints();

        // TODO: 2. Look for a connected component of === that does not have any incoming directed constraint
        //  (that is, <== or component constraint) from a signal outside the connected component.

        let mut filtered_connected_components = connected_components.iter()
            .filter(|&comp| {

                // TODO: Check that this is correct
                let any_incoming_assignments_from_outside_component =
                    comp.nodes.iter().any(|signal| {
                        match self.incoming_safe_assignments.get(signal) {
                            None => { false }
                            Some(safe_assignment_idx) => {
                                let rhs_signals = &self.safe_assignments[*safe_assignment_idx].rhs_signals;
                                let any_rhs_signal_outside_connected_component = rhs_signals.iter()
                                    .any(|s| {
                                        comp.nodes.contains(s)
                                    });

                                any_rhs_signal_outside_connected_component
                            }
                        }
                    });

                let any_incoming_component_edges =
                    comp.nodes.iter().any(|signal| {
                        match self.nodes[signal] {
                            // TODO: Only collect components with inputs from outside the component
                            Node::SubComponentOutputSignal(cmp_index) => {
                                let cmp_inputs = &self.subcomponents[&cmp_index].input_signals;
                                let any_cmp_inputs_outside_connected_component = cmp_inputs.iter()
                                    .any(|s| {
                                        comp.nodes.contains(s)
                                    });

                                any_cmp_inputs_outside_connected_component
                            }
                            _ => { false }
                        }
                    });

                !(any_incoming_assignments_from_outside_component || any_incoming_component_edges)
            });

        let maybe_connected_component = filtered_connected_components.next();
        if maybe_connected_component.is_none() {
            // There are cycles between connected components, cannot verify
            // TODO: Better error handling
            println!("There is no === constraint connected component without cycles! Aborting verify...");
            return false;
        }

        let connected_component = maybe_connected_component.unwrap();

        // TODO: Add all connected component signals and constraints into a Groebner basis structure

        let already_added_unsafe_constraints = HashSet::<UnsafeConstraintIndex>::new();
        let mut polynomial_constraints = vec![];

        for signal in &connected_component.nodes {
            // Add === constraints if not already added
            let maybe_constraints = self.edge_constraints.get(signal);
            if let Some(unsafe_constraints) = maybe_constraints {
                for unsafe_constraint_index in unsafe_constraints {
                    if !already_added_unsafe_constraints.contains(unsafe_constraint_index) {
                        let unsafe_constraint = &self.unsafe_constraints[*unsafe_constraint_index];
                        let constraint = constraint_storage.read_constraint(
                            unsafe_constraint.associated_constraint
                        ).unwrap();

                        polynomial_constraints.push(constraint);
                    }
                }
            }

            // TODO: Better comments
            // Only add safe_assignment <== in LHS, as then we are sure that is inside
            if let Some(safe_assignment_index) = self.incoming_safe_assignments.get(signal) {
                // This signal is the LHS of a safe assignment, whose RHS must all be inside the
                //  connected component
                let constraint_idx = self.safe_assignments[*safe_assignment_index].associated_constraint;

                polynomial_constraints.push(constraint_storage.read_constraint(constraint_idx).unwrap());
            }


            // TODO: Handle components
            if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[signal] {
                let cmp = &self.subcomponents[&cmp_index];
                if !cmp.input_signals.is_empty() {
                    // We need to instantiate the component and add the constraints here
                    todo!()
                }
            }
        }

        // Compute the signals to fix, which are the signals which have dependencies outside the
        //  connected component

        let signals_to_fix = connected_component.nodes.iter().filter(|signal_index| {
            // All component outputs have to be fixed
            if let Node::OutputSignal = self.nodes[signal_index] {
                return true;
            }

            // Check if there are any outgoing edge outside the component
            let outgoing_safe_assignments = self.outgoing_safe_assignments.get(signal_index);
            if let Some(safe_assignments) = outgoing_safe_assignments {
                let any_rhs_outside_connected_component = safe_assignments.iter()
                    .any(|safe_assignment_idx| {
                        let lhs = self.safe_assignments[*safe_assignment_idx].lhs_signal;
                        !connected_component.nodes.contains(&lhs)
                    });

                if any_rhs_outside_connected_component {
                    return true;
                }
            }

            // Check if this is a subcomponent input and has subcomponent outputs outside connected_component
            if let SubComponentInputSignal(cmp_index) = self.nodes[signal_index] {
                let any_subcomponent_output_outside_connected_component = self.subcomponents[&cmp_index].output_signals.iter()
                    .any(|cmp_output_signal| {
                        !connected_component.nodes.contains(cmp_output_signal)
                    });

                if any_subcomponent_output_outside_connected_component {
                    return true;
                }
            }

            // None of the above conditions hold, so this node should not be classified as an output to be fixed
            false
        }).copied().collect();

        // TODO: Remove all non-output nodes and fix outputs

        // TODO: Draw the state of the map now

        // TODO: If the Groebner basis system can be solved using Gaussian elimination, fix nodes directly
        //  Maybe do this on the Groebner Basis backend?

        let polynomial_system = PolynomialSystemFixedSignal {
            constraints: polynomial_constraints,
            signals_to_fix,
        };

        true
    }

    fn compute_connected_components_unsafe_constraints(&self) -> Vec<ConnectedComponent> {
        let remaining_nodes = self.nodes.clone();
        let mut connected_components = Vec::new();

        while !remaining_nodes.is_empty() {
            let initial_node = self.nodes.iter().next().unwrap();
            let mut already_visited = BTreeSet::new();
            self.dfs_mark(*initial_node.0, &mut already_visited);

            connected_components.push(ConnectedComponent {
                nodes: already_visited,
            });
        }

        connected_components
    }

    fn dfs_mark(&self, signal: SignalIndex, already_visited: &mut BTreeSet<SignalIndex>) {
        if already_visited.contains(&signal) {
            return;
        }

        already_visited.insert(signal);

        // TODO: How to handle components?
        //  Do not add all outputs if one output is added, instead, extract only the relevant
        //  constraints from the subcomponent
        // if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[&signal] {
        //     let cmp = &self.subcomponents[&cmp_index];
        //     for output in &cmp.output_signals {
        //         if *output != signal {
        //             self.dfs_mark(signal, already_visited);
        //         }
        //     }
        // }

        let edges = self.edge_constraints.get(&signal);
        if edges.is_none() {
            return;
        }

        for &constraint in edges.unwrap() {
            let signals = &self.unsafe_constraints[constraint].signals;
            for other_signal in signals {
                if signal != *other_signal {
                    self.dfs_mark(signal, already_visited);
                }
            }
        }
    }

    // This function will propagate the fixed_nodes through the different type of constraints by
    // substituting the fixed value into all the appearing constraints, fixing
    fn propagate_fixed_nodes(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        let mut it_num = 0;
        while !self.fixed_nodes.is_empty() {
            let node = self.fixed_nodes.pop_last().unwrap();
            self.propagate_fixed_node(node, context, constraint_storage);

            // TODO: Remove the following DEBUG print
            print_verification_graph(
                self,
                context,
                Path::new(context.base_path)
                    .join(format!(r"svg/step-{}.svg", it_num))
                    .as_path(),
            )
                .unwrap();

            it_num += 1;
        }
    }

    // Propagate just one fixed_node.
    fn propagate_fixed_node(
        &mut self,
        fixed_node: SignalIndex,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        // 1. Check if this node is an output signal, and decrement the number of not_yet_fixed
        //      signals if it is
        if let Node::OutputSignal = self.nodes[&fixed_node] {
            self.number_of_outputs_not_yet_fixed -= 1;
        }

        assert!(self.incoming_safe_assignments.get(&fixed_node).is_none());

        // TODO: 2. Substitute in constraints and propagate fixed_nodes through them

        // 2.1 Safe assignments <==

        if self.outgoing_safe_assignments.contains_key(&fixed_node) {
            for ass_idx in &self.outgoing_safe_assignments[&fixed_node] {
                let ass = &mut self.safe_assignments[*ass_idx];
                substitute_witness_signal_into_storage(
                    ass.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );
                ass.rhs_signals.remove(&fixed_node);
                propagate_fixed_node_in_safe_assignment(
                    &mut self.fixed_nodes,
                    ass,
                    &mut self.incoming_safe_assignments,
                );
            }

            // Clear all outgoing_safe_assignments for this node
            self.outgoing_safe_assignments.remove(&fixed_node);
        }

        // 2.2 Unsafe constraints ===

        if self.edge_constraints.contains_key(&fixed_node) {
            for unsafe_constraint_idx in &self.edge_constraints[&fixed_node] {
                let unsafe_constraint = &mut self.unsafe_constraints[*unsafe_constraint_idx];
                substitute_witness_signal_into_storage(
                    unsafe_constraint.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );
                unsafe_constraint.signals.remove(&fixed_node);

                propagate_fixed_node_in_unsafe_constraint(
                    constraint_storage,
                    &mut self.fixed_nodes,
                    unsafe_constraint,
                );
            }

            // Clear all edge_constraints for this node
            self.edge_constraints.remove(&fixed_node);
        }

        // TODO: 2.3 Sub-components
        if let Node::SubComponentInputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
            cmp.input_signals.remove(&fixed_node);

            if cmp.input_signals.is_empty() {
                // We have finally fixed_all inputs, we can fix the output and recursively
                // verify the subcomponent
                self.sub_components_to_verify.push(cmp_index);

                for output_signal in &cmp.output_signals {
                    self.fixed_nodes.insert(*output_signal);
                }
            }
        }

        // 3. Remove this node from the graph

        // TODO: Are there any more things to remove apart from the node?

        // If this is an output node, we have to remmve it from the outputs of its subcomponent first
        if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
            cmp.output_signals.remove(&fixed_node);
        }

        self.nodes.remove(&fixed_node);
    }

    // pub fn get_unsafe_constraints(&self) -> impl Iterator<Item=&UnsafeConstraint> {
    //     self.unsafe_constraints.iter()
    // }
}

// TODO: Study when to apply substitutions. If we want to prove weak safety (only
//  for one input) we could probably apply the substitutions one by one when fixing signals.
//  We need to study the case of strong safety (for all inputs)

//  Substitute the symbolic value of a signal by its witness value on the constraint_storage for a
//   given constraint index.
fn substitute_witness_signal_into_storage(
    constraint_idx: ConstraintIndex,
    context: &InputDataContextView,
    constraint_storage: &mut ConstraintStorage,
    fixed_signal: SignalIndex,
) {
    let mut constraint = constraint_storage.read_constraint(constraint_idx).unwrap();

    let mut substitution_to_coefficients = HashMap::new();
    substitution_to_coefficients.insert(
        Constraint::constant_coefficient(),
        context.witness[&fixed_signal].clone(),
    );

    let substitution = Substitution::<usize>::new(
        fixed_signal,
        ArithmeticExpression::Linear {
            coefficients: substitution_to_coefficients,
        },
    )
        .unwrap();

    Constraint::apply_substitution(&mut constraint, &substitution, &context.field);

    // TODO: Check that we are doing a correct normalization
    Constraint::fix_constraint(&mut constraint, &context.field);

    constraint_storage.replace(constraint_idx, constraint);
}

// This function checks a safe assignment. If all RHS values have been fixed, the LHS will
// also be fixed. Called both on creation of the VerificationGraph and on fixed node propagation
fn propagate_fixed_node_in_safe_assignment(
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    assignment: &mut SafeAssignment,
    incoming_safe_assignments: &mut BTreeMap<SignalIndex, SafeAssignmentIndex>,
) {
    // Fix the LHS of a '<==' assignment if the RHS does not have any signals (are constants)
    // TODO: Is this condition correct and complete for safe assignments?
    if assignment.rhs_signals.is_empty() {
        fixed_nodes.insert(assignment.lhs_signal);

        // Clean up constraint
        incoming_safe_assignments.remove(&assignment.lhs_signal);
        assignment.active = false;
    }
}

// This function checks an unsafe constraint. If it only contains one unfixed signal, the constraint
// is linear and its coefficient is non-zero, that signal will also be marked fixed.
fn propagate_fixed_node_in_unsafe_constraint(
    constraint_storage: &ConstraintStorage,
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    unsafe_constraint: &mut UnsafeConstraint,
) {
    // Fix the only signal of a === constraint if it is the only signal, the constraint is
    // linear, and its coefficient is non-zero
    // TODO: Is this condition correct and complete for unsafe assignments?

    if unsafe_constraint.signals.len() == 1 {
        let signal = unsafe_constraint.signals.last().unwrap();
        let constraint = constraint_storage
            .read_constraint(unsafe_constraint.associated_constraint)
            .unwrap();

        // TODO: If in the future we want to add support for verifying a subcomponent for all different
        //  inputs, we should check whether we should substitute values into the constraint here.

        // TODO: Check if this is the correct form to compute whether the constraint is linear
        if Constraint::<usize>::is_linear(&constraint) {
            let coefficient = constraint.c().get(signal).unwrap();
            if !coefficient.is_zero() {
                fixed_nodes.insert(*signal);

                // Clean up constraint
                unsafe_constraint.active = false;
            }
        }
    }
}
