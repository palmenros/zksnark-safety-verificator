use crate::verification_graph::Node::SubComponentInputSignal;
use crate::verifier::{
    ModuleUnsafeReason, PolynomialSystemFixedSignal, SafetyConditions,
    SubComponentVerificationResult, SubComponentVerificationResultKind, VerificationException,
};
use crate::{ComponentIndex, ConstraintIndex, InputDataContextView, SignalIndex};
use circom_algebra::algebra::{ArithmeticExpression, Constraint, Substitution};
use circom_algebra::constraint_storage::ConstraintStorage;
use num_bigint_dig::BigInt;
use num_traits::Zero;
use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};

#[allow(clippy::enum_variant_names)]
#[derive(Clone)]
pub enum Node {
    InputSignal,
    OutputSignal,
    IntermediateSignal,

    SubComponentInputSignal(ComponentIndex),
    SubComponentOutputSignal(ComponentIndex),
}

#[derive(Clone)]
pub struct SafeAssignment {
    // Signal index of the signal appearing in the LHS of the '<==' assignment
    pub lhs_signal: SignalIndex,

    // Signal indices of the signals appearing in the RHS of the '==>' assignment
    pub rhs_signals: BTreeSet<SignalIndex>,

    // Constraint index of the constraint associated to the safe assignment
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A constraint of the type '===' that has not been generated by a safe assignment '<=='

#[derive(Clone)]
pub struct UnsafeConstraint {
    // List of *all* participating signals in this constraint, including the key of edge_constraints
    pub signals: BTreeSet<SignalIndex>,

    // Constraint index
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A subcomponent, which has input_signals and output_signals
pub struct SubComponent {
    // input_signals and output_signals are the current inputs and outputs of this component, after
    // possibly removing some nodes by fixed_nodes propagation.
    pub input_signals: BTreeSet<SignalIndex>,
    pub output_signals: BTreeSet<SignalIndex>,

    // original_input_signals and original_output_signals are the original input and output signals
    // of the component, before propagating and possibly removing inputs and outputs
    // TODO: Maybe we don't need to store these, right now we don't use them.
    pub original_input_signals: BTreeSet<SignalIndex>,
    pub original_output_signals: BTreeSet<SignalIndex>,
}

pub type SafeAssignmentIndex = usize;
pub type UnsafeConstraintIndex = usize;

// NOTE: For reproducibility, I have declared the HashMaps as BTreeMap, so they are ordered.
//      Explore whether it's a good idea to change them to HashMap
pub struct VerificationGraph {
    // List of nodes in the graph. Each signal has a node, and it can be of multiple types
    pub nodes: BTreeMap<SignalIndex, Node>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the LHS of the assignment
    pub incoming_safe_assignments: BTreeMap<SignalIndex, SafeAssignmentIndex>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the RHS of the assignment
    pub outgoing_safe_assignments: BTreeMap<SignalIndex, BTreeSet<SafeAssignmentIndex>>,

    // Given a node, it returns the list of all constraints '===' that are not a result of safe
    //    assignments '<==' in which this signal appears
    pub edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>>,

    // Given a component index, it returns the SubComponent struct
    pub subcomponents: BTreeMap<ComponentIndex, SubComponent>,

    // List of all safe_assignments (<==). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub safe_assignments: Vec<SafeAssignment>,

    // List of all unsafe_constraints (===). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub unsafe_constraints: Vec<UnsafeConstraint>,

    //  List of nodes that have been fixed (proved to be unique) but not yet removed from the graph
    pub fixed_nodes: BTreeSet<SignalIndex>,

    // Number of outputs that have not yet been fixed
    pub number_of_outputs_not_yet_fixed: usize,

    // List of subcomponents to verify in order for this component to be verified.
    pub sub_components_to_verify: Vec<ComponentIndex>,

    // Fields for Debug SVG printing
    pub debug_polynomial_system_generator_data: DebugPolynomialSystemGeneratorData,
}

struct ConnectedComponent {
    nodes: BTreeSet<SignalIndex>,
}

#[derive(Default)]
pub struct DebugPolynomialSystemGeneratorData {
    // Nodes in the polynomial system
    pub nodes: BTreeSet<SignalIndex>,

    // Safe assignments in the polynomial system
    pub safe_assignments: BTreeSet<SafeAssignmentIndex>,

    // Unsafe constraints in the polynomial system
    pub unsafe_constraints: BTreeSet<UnsafeConstraintIndex>,
}

impl VerificationGraph {
    pub fn new(
        context: &InputDataContextView,
        constraint_storage: &ConstraintStorage,
    ) -> VerificationGraph {
        let tree_constraints = context.tree_constraints;

        let mut nodes = BTreeMap::<SignalIndex, Node>::new();
        let mut subcomponents = BTreeMap::<ComponentIndex, SubComponent>::new();

        // Outputs
        for idx in 0..tree_constraints.number_outputs {
            let s = idx + tree_constraints.initial_signal;
            nodes.insert(s, Node::OutputSignal);
        }

        let mut input_signals = BTreeSet::new();

        // Inputs
        for idx in 0..tree_constraints.number_inputs {
            let s = idx + tree_constraints.number_outputs + tree_constraints.initial_signal;
            nodes.insert(s, Node::InputSignal);
            input_signals.insert(s);
        }

        // Intermediates
        let number_intermediates = tree_constraints.number_signals
            - tree_constraints.number_outputs
            - tree_constraints.number_inputs;

        for idx in 0..number_intermediates {
            let s = idx
                + tree_constraints.number_outputs
                + tree_constraints.number_inputs
                + tree_constraints.initial_signal;

            nodes.insert(s, Node::IntermediateSignal);
        }

        // Components

        // TODO: We should make a difference between safe and unsafe subcomponents. By default, we will
        //  assume that all subcomponents ought to be safe (that is, their output must remain fixed
        //  if the input is fixed). We should allow "unsafe" subcomponents (such as Inverse), which might
        //  not fully determine their outputs when their inputs are fixed. In that case, we should "extract"
        //  the subcomponent signals, constraints and subcomponents into the parent component, so
        //  we can perform the algorithm taking the relationships into account, not as a black box.
        //      This information about unsafe components should be passed by an input .json.
        //  Right now we are treating all subcomponents as safe subcomponents, but we should
        //  implement support for unsafe subcomponents.
        //      However, these "unsafe" components are quite rare. They are not used much in practice.

        for (cmp_index, c) in tree_constraints.subcomponents.iter().enumerate() {
            let mut subcomponent_inputs = BTreeSet::new();
            let mut subcomponent_outputs = BTreeSet::new();

            // Subcomponent inputs
            for idx in 0..c.number_inputs {
                let s = idx + c.number_outputs + c.initial_signal;
                subcomponent_inputs.insert(s);
                nodes.insert(s, Node::SubComponentInputSignal(cmp_index));
            }

            for idx in 0..c.number_outputs {
                let s = idx + c.initial_signal;
                subcomponent_outputs.insert(s);

                nodes.insert(s, Node::SubComponentOutputSignal(cmp_index));
            }

            subcomponents.insert(
                cmp_index,
                SubComponent {
                    input_signals: subcomponent_inputs.clone(),
                    output_signals: subcomponent_outputs.clone(),
                    original_input_signals: subcomponent_inputs,
                    original_output_signals: subcomponent_outputs,
                },
            );
        }

        let mut incoming_safe_assignments = BTreeMap::<SignalIndex, SafeAssignmentIndex>::new();
        let mut outgoing_safe_assignments =
            BTreeMap::<SignalIndex, BTreeSet<SafeAssignmentIndex>>::new();
        let mut safe_assignments = vec![];

        let mut is_constraint_double_arrow = BTreeSet::new();

        // Add safe assignment edges
        for (constraint, lhs_signal) in &tree_constraints.are_double_arrow {
            is_constraint_double_arrow.insert(*constraint);

            let mut signals: BTreeSet<SignalIndex> = constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_cloned_signals_ordered();
            signals.remove(lhs_signal);

            let safe_assignment = SafeAssignment {
                lhs_signal: *lhs_signal,
                rhs_signals: signals,
                associated_constraint: *constraint,
                active: true,
            };

            let safe_assignment_idx = safe_assignments.len();
            safe_assignments.push(safe_assignment);

            incoming_safe_assignments.insert(*lhs_signal, safe_assignment_idx);

            // Outgoings
            for rhs_signal in constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_signals()
            {
                if rhs_signal != lhs_signal {
                    outgoing_safe_assignments
                        .entry(*rhs_signal)
                        .or_insert(BTreeSet::new())
                        .insert(safe_assignment_idx);
                }
            }
        }

        let mut edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>> =
            BTreeMap::new();
        let mut unsafe_constraints: Vec<UnsafeConstraint> = vec![];

        // Add unsafe edges
        let constraints_range = tree_constraints.initial_constraint
            ..(tree_constraints.initial_constraint + tree_constraints.no_constraints);
        for (constraint_index, c) in constraints_range
            .filter(|idx| !is_constraint_double_arrow.contains(idx))
            .map(|x| (x, constraint_storage.read_constraint(x).unwrap()))
        {
            let signals = c.take_cloned_signals_ordered();

            let unsafe_constraint_index = unsafe_constraints.len();

            for &signal in &signals {
                // let vector: BTreeSet<SignalIndex> = signals.iter().filter(|x| **x != signal).copied().collect();
                edge_constraints
                    .entry(signal)
                    .or_insert(BTreeSet::new())
                    .insert(unsafe_constraint_index);
            }

            unsafe_constraints.push(UnsafeConstraint {
                signals,
                associated_constraint: constraint_index,
                active: true,
            });
        }

        // Compute initial fixed_nodes, which should include the inputs, safe assignments of only constants
        //  (for example, i <== 2) and linear constraints with only one appearing signal and non-zero coefficient
        //  (for example, 3*s===1).
        // TODO: Maybe there are more fixed_nodes initial situations to take into account?

        // Input signals
        let mut fixed_nodes = BTreeSet::new();
        fixed_nodes.append(&mut input_signals);

        // Safe assignments of only constants
        for ass in &mut safe_assignments {
            propagate_fixed_node_in_safe_assignment(
                &mut fixed_nodes,
                ass,
                &mut incoming_safe_assignments,
            );
        }

        // Unsafe constraints ===
        for unsafe_constraint in &mut unsafe_constraints {
            propagate_fixed_node_in_unsafe_constraint(
                constraint_storage,
                &mut fixed_nodes,
                unsafe_constraint,
            );
        }

        // Components without any input (such as Constant components)
        let mut sub_components_to_verify = vec![];

        for (idx, cmp) in &subcomponents {
            if cmp.input_signals.is_empty() {
                sub_components_to_verify.push(*idx);

                for output in &cmp.output_signals {
                    fixed_nodes.insert(*output);
                }
            }
        }

        VerificationGraph {
            nodes,
            incoming_safe_assignments,
            outgoing_safe_assignments,
            edge_constraints,
            subcomponents,
            safe_assignments,
            unsafe_constraints,
            fixed_nodes,
            number_of_outputs_not_yet_fixed: tree_constraints.number_outputs,
            sub_components_to_verify,
            debug_polynomial_system_generator_data: Default::default(),
        }
    }

    pub fn verify_subcomponents(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) -> SubComponentVerificationResult {
        // TODO: Maybe there are some easy. common, special cases to consider before executing
        //          the full algorithm.

        context
            .svg_printer
            .print_verification_graph(
                self,
                context,
                format!("general-{}", context.tree_constraints.component_name).as_str(),
                Some(
                    format!(
                        "{}: {}",
                        context.tree_constraints.component_name,
                        context.tree_constraints.template_name
                    )
                        .as_str(),
                ),
            )
            .unwrap();

        let mut pol_systems_to_be_fixed: Vec<PolynomialSystemFixedSignal> = vec![];

        loop {
            self.propagate_fixed_nodes(context, constraint_storage);

            if self.number_of_outputs_not_yet_fixed == 0 {
                // Verification complete, next subcomponents

                let mut subcomponent_verification_results: Vec<SubComponentVerificationResult> =
                    vec![];

                subcomponent_verification_results.reserve(self.sub_components_to_verify.len());

                // TODO: Verify that sub_components_to_verify has the correct subcomponents. If so,
                //  remove the following comments

                // let num_subcomponents = context.tree_constraints.subcomponents.len();
                // subcomponent_verification_results.reserve(num_subcomponents);
                //for subcomponent_idx in 0..num_subcomponents {

                for &subcomponent_idx in &self.sub_components_to_verify {
                    let subcomponent_context =
                        context.get_subcomponent_context_view(subcomponent_idx);
                    let mut subcomponent_verification_graph =
                        VerificationGraph::new(&subcomponent_context, constraint_storage);

                    subcomponent_verification_results.push(
                        subcomponent_verification_graph
                            .verify_subcomponents(&subcomponent_context, constraint_storage),
                    );
                }

                return SubComponentVerificationResult {
                    kind: SubComponentVerificationResultKind::ModuleConditionallySafe(
                        SafetyConditions {
                            subcomponents: subcomponent_verification_results,
                            pol_systems: pol_systems_to_be_fixed,
                        },
                    ),
                    subcomponent_name: context.tree_constraints.component_name.clone(),
                };
            }

            // If there are no === constraints remaining, then the unfixed outputs will remain unfixed

            let is_there_any_unsafe_constraint_remaining =
                self.edge_constraints.iter().any(|(_, set)| !set.is_empty());

            if !is_there_any_unsafe_constraint_remaining {
                let unsafe_outputs = self
                    .nodes
                    .iter()
                    .filter(|(_, n)| matches!(n, Node::OutputSignal))
                    .map(|(signal_index, _)| signal_index);

                return SubComponentVerificationResult {
                    kind: SubComponentVerificationResultKind::ModuleUnsafe(
                        ModuleUnsafeReason::UnfixedOutputsAfterPropagation(
                            unsafe_outputs
                                .map(|idx| context.signal_name_map[idx].clone())
                                .collect(),
                        ),
                    ),
                    subcomponent_name: context.tree_constraints.component_name.clone(),
                };
            }

            // Else, if there are === constraints remaining, we should merge all === constraint
            //  cycles until there are no more connected components that can be merged
            let maybe_pol_system =
                self.merge_unsafe_constraints_connected_component(context, constraint_storage);

            if let Some(pol_system) = maybe_pol_system {
                pol_systems_to_be_fixed.push(pol_system);
            } else {
                // There is some cyclic dependencies between the different === constraints connected
                //  components, abort

                // TODO: Maybe use some heuristic to make a bigger connected component?
                // TODO: If <== from unfixed signal, add it to connected component.
                return SubComponentVerificationResult {
                    kind: SubComponentVerificationResultKind::Exception(
                        VerificationException::NoUnsafeConstraintConnectedComponentWithoutCycles,
                    ),
                    subcomponent_name: context.tree_constraints.component_name.clone(),
                };
            }
        }
    }

    // This function looks for a connected of === constraints that can be reduced using Groebner
    //  bases. Returns true if it has been able to merge such a connected component, false otherwise
    fn merge_unsafe_constraints_connected_component(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &ConstraintStorage,
    ) -> Option<PolynomialSystemFixedSignal> {
        // Look for a connected component of === that does not have any incoming directed constraint
        //  (that is, <== or component constraint) from a signal outside the connected component.
        //  If we cannot find such a connected component, return None. If we find such a connected
        //  component return it

        // 1. Compute connected components of === constraints
        // FIXME: Check how to we handle components inputs / outputs if we allow components in
        //  each connected component.
        let connected_components = self.compute_connected_components_unsafe_constraints();

        // 2. Look for a connected component of === that does not have any incoming directed constraint
        //  (that is, <== or component constraint) from a signal outside the connected component.

        // FIXME: Now we only select a connected component where at least there is a ===
        //  constraint? Maybe there are cases were that is not appropriate.
        let mut filtered_connected_components = connected_components.iter().filter(|&comp| {
            let any_incoming_assignments_from_outside_component =
                comp.nodes
                    .iter()
                    .any(|signal| match self.incoming_safe_assignments.get(signal) {
                        None => false,
                        Some(safe_assignment_idx) => {
                            let rhs_signals =
                                &self.safe_assignments[*safe_assignment_idx].rhs_signals;
                            let any_rhs_signal_outside_connected_component =
                                rhs_signals.iter().any(|s| !comp.nodes.contains(s));
                            any_rhs_signal_outside_connected_component
                        }
                    });

            let any_incoming_component_edges = comp.nodes.iter().any(|signal| {
                match self.nodes[signal] {
                    // Only collect components with inputs from outside the component
                    Node::SubComponentOutputSignal(cmp_index) => {
                        let cmp_inputs = &self.subcomponents[&cmp_index].input_signals;
                        let any_cmp_inputs_outside_connected_component =
                            cmp_inputs.iter().any(|s| !comp.nodes.contains(s));

                        any_cmp_inputs_outside_connected_component
                    }
                    _ => false,
                }
            });

            // Check that the chosen connected component has at least one === constraint
            let any_unsafe_constraint =
                comp.nodes
                    .iter()
                    .any(|signal| match self.edge_constraints.get(signal) {
                        None => false,
                        Some(x) => !x.is_empty(),
                    });

            !(any_incoming_assignments_from_outside_component || any_incoming_component_edges)
                && any_unsafe_constraint
        });

        // The following comments print the number of connected components found before and
        //  after filtering them for the conditions above.

        // let filtered_vec: Vec<_> = filtered_connected_components.clone().collect();
        // println!("Unfiltered: {}, Filtered: {}", connected_components.len(), filtered_vec.len());

        let maybe_connected_component = filtered_connected_components.next();
        let connected_component = maybe_connected_component?;

        let mut already_added_unsafe_constraints = HashSet::<UnsafeConstraintIndex>::new();
        let mut polynomial_constraints = vec![];

        // Used for debug graph printing
        let mut debug_polynomial_safe_assignments = BTreeSet::new();
        let mut debug_polynomial_unsafe_constraints = BTreeSet::new();

        for signal in &connected_component.nodes {
            // Add === constraints if not already added
            let maybe_constraints = self.edge_constraints.get(signal);
            if let Some(unsafe_constraints) = maybe_constraints {
                for unsafe_constraint_index in unsafe_constraints {
                    if !already_added_unsafe_constraints.contains(unsafe_constraint_index) {
                        let unsafe_constraint = &self.unsafe_constraints[*unsafe_constraint_index];
                        let constraint = constraint_storage
                            .read_constraint(unsafe_constraint.associated_constraint)
                            .unwrap();

                        polynomial_constraints.push(constraint);
                        debug_polynomial_unsafe_constraints.insert(*unsafe_constraint_index);
                        already_added_unsafe_constraints.insert(*unsafe_constraint_index);
                    }
                }
            }

            // Only add safe_assignment <== in LHS, as then we are sure that is inside
            if let Some(safe_assignment_index) = self.incoming_safe_assignments.get(signal) {
                // This signal is the LHS of a safe assignment, whose RHS must all be inside the
                //  connected component
                let constraint_idx =
                    self.safe_assignments[*safe_assignment_index].associated_constraint;

                polynomial_constraints
                    .push(constraint_storage.read_constraint(constraint_idx).unwrap());
                debug_polynomial_safe_assignments.insert(*safe_assignment_index);
            }

            // TODO: In the future we should handle components inside the connected component.
            //  However, this is quite rare in real Circom code and adds much complexity.
            if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[signal] {
                let cmp = &self.subcomponents[&cmp_index];

                // If the component doesn't have any input_signals, the outputs have already been
                //  fixed and can be treated as normal signals.
                if !cmp.input_signals.is_empty() {
                    // We need to instantiate the component and add the constraints here
                    todo!()
                }
            }
        }

        // Compute the signals to fix, which are the signals which have dependencies outside the
        //  connected component

        let mut signals_to_fix = connected_component
            .nodes
            .iter()
            .filter(|signal_index| {
                // All component outputs have to be fixed
                if let Node::OutputSignal = self.nodes[signal_index] {
                    return true;
                }

                // Check if there are any outgoing edge outside the component
                let outgoing_safe_assignments = self.outgoing_safe_assignments.get(signal_index);
                if let Some(safe_assignments) = outgoing_safe_assignments {
                    let any_rhs_outside_connected_component =
                        safe_assignments.iter().any(|safe_assignment_idx| {
                            let lhs = self.safe_assignments[*safe_assignment_idx].lhs_signal;
                            !connected_component.nodes.contains(&lhs)
                        });

                    if any_rhs_outside_connected_component {
                        return true;
                    }
                }

                // Check if this is a subcomponent input and has subcomponent outputs outside connected_component
                if let SubComponentInputSignal(cmp_index) = self.nodes[signal_index] {
                    let any_subcomponent_output_outside_connected_component =
                        self.subcomponents[&cmp_index].output_signals.iter().any(
                            |cmp_output_signal| {
                                !connected_component.nodes.contains(cmp_output_signal)
                            },
                        );

                    if any_subcomponent_output_outside_connected_component {
                        return true;
                    }
                }

                // None of the above conditions hold, so this node should not be classified as an output to be fixed
                false
            })
            .copied()
            .collect();

        // Fix all the nodes that should be fixed
        self.fixed_nodes.append(&mut signals_to_fix);

        // Draw the state of the component graph now

        let debug_polynomial_system_generator_data = DebugPolynomialSystemGeneratorData {
            nodes: connected_component.nodes.clone(),
            safe_assignments: debug_polynomial_safe_assignments,
            unsafe_constraints: debug_polynomial_unsafe_constraints,
        };

        self.debug_polynomial_system_generator_data = debug_polynomial_system_generator_data;

        // Draw

        context
            .svg_printer
            .print_verification_graph(
                self,
                context,
                format!(
                    "selected_connected_component-{}",
                    context.tree_constraints.component_name
                )
                    .as_str(),
                Some(
                    format!(
                        "Selected connected component of {}: {}",
                        context.tree_constraints.component_name,
                        context.tree_constraints.template_name
                    )
                        .as_str(),
                ),
            )
            .unwrap();

        // Remove all unfixed nodes, edges

        for signal in &connected_component.nodes {
            // 1. Handle unsafe constraints

            // As we are using DFS across === constraint edges, we can directly remove all ===
            //  constrains this node is associated with, even for fixed_nodes

            if self.edge_constraints.contains_key(signal) {
                for unsafe_constraint_index in &self.edge_constraints[signal] {
                    self.unsafe_constraints[*unsafe_constraint_index].active = false;
                }
            }

            self.edge_constraints.remove(signal);

            // 2. Handle safe assignments

            let node_fixed = self.fixed_nodes.contains(signal);

            // Fixed or not fixed, delete the assignment where we are the LHS, as
            //  they must come from inside the connected component
            if let Some(safe_assignment_idx) = self.incoming_safe_assignments.get(signal) {
                self.safe_assignments[*safe_assignment_idx].active = false;
                self.incoming_safe_assignments.remove(signal);
            }

            // Only delete our outgoing assignment if we are not fixed
            if !node_fixed {
                // We do not need to set to inactive, as that will already be done by the LHS, just
                //  remove it
                self.outgoing_safe_assignments.remove(signal);
            }

            // 3. Handle components

            // FIXME: Possibly modify this after implementing components in polynomial connected components

            if !node_fixed {
                if let Node::SubComponentInputSignal(cmp_index) = self.nodes[signal] {
                    // In this case, as we are not fixed, the output must be inside the connected component

                    let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
                    cmp.input_signals.remove(signal);
                }

                if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[signal] {
                    let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
                    cmp.output_signals.remove(signal);
                }
            }
            // 4. Delete this node if it wasn't to be fixed

            if !node_fixed {
                self.nodes.remove(signal);
            }
        }

        // Redraw after removing all unfixed_nodes and edges

        self.debug_polynomial_system_generator_data = Default::default();
        context
            .svg_printer
            .print_verification_graph(
                self,
                context,
                format!(
                    "post-constraint-elimination-{}",
                    context.tree_constraints.component_name
                )
                    .as_str(),
                Some(
                    format!(
                        "{}: {}",
                        context.tree_constraints.component_name,
                        context.tree_constraints.template_name
                    )
                        .as_str(),
                ),
            )
            .unwrap();

        let polynomial_system = PolynomialSystemFixedSignal {
            constraints: polynomial_constraints,
            signals_to_fix: self.fixed_nodes.clone(),
            template_name: context.tree_constraints.template_name.clone(),
            component_name: context.tree_constraints.component_name.clone(),
        };

        Some(polynomial_system)
    }

    fn compute_connected_components_unsafe_constraints(&self) -> Vec<ConnectedComponent> {
        let mut remaining_nodes = self.nodes.clone();
        let mut connected_components = Vec::new();

        while !remaining_nodes.is_empty() {
            let initial_node = remaining_nodes.iter().next().unwrap();
            let mut already_visited = BTreeSet::new();
            self.dfs_mark(*initial_node.0, &mut already_visited);

            for visited_node in &already_visited {
                remaining_nodes.remove(visited_node);
            }

            connected_components.push(ConnectedComponent {
                nodes: already_visited,
            });
        }

        connected_components
    }

    fn dfs_mark(&self, signal: SignalIndex, already_visited: &mut BTreeSet<SignalIndex>) {
        if already_visited.contains(&signal) {
            return;
        }

        already_visited.insert(signal);

        // TODO: How to handle components when marking for the connected component?
        //  Maybe add all outputs and inputs if one output is added? and then filter then unneeded constraints
        //  before solving with Groebner basis? What to do with inputs?
        //  Allowing components in connected components adds a lot of complexity and this case
        //  rarely appears in real code.

        // if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[&signal] {
        //     let cmp = &self.subcomponents[&cmp_index];
        //     for output in &cmp.output_signals {
        //         if *output != signal {
        //             self.dfs_mark(*output, already_visited);
        //         }
        //     }
        //     for input in &cmp.input_signals {
        //         self.dfs_mark(*input, already_visited);
        //     }
        // }

        let edges = self.edge_constraints.get(&signal);
        if edges.is_none() {
            return;
        }

        for &constraint in edges.unwrap() {
            let signals = &self.unsafe_constraints[constraint].signals;
            for other_signal in signals {
                if signal != *other_signal {
                    self.dfs_mark(*other_signal, already_visited);
                }
            }
        }
    }

    // This function will propagate the fixed_nodes through the different type of constraints by
    // substituting the fixed value into all the appearing constraints, fixing
    fn propagate_fixed_nodes(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        while !self.fixed_nodes.is_empty() {
            let node = self.fixed_nodes.pop_last().unwrap();
            self.propagate_fixed_node(node, context, constraint_storage);

            if !context.options.generate_only_last_propagation_svg {
                self.draw_propagation_svg(context);
            }
        }

        if context.options.generate_svg_diagrams {
            self.draw_propagation_svg(context);
        }
    }

    fn draw_propagation_svg(&self, context: &InputDataContextView) {
        context
            .svg_printer
            .print_verification_graph(
                self,
                context,
                format!("propagate-{}", context.tree_constraints.component_name).as_str(),
                Some(
                    format!(
                        "{}: {}",
                        context.tree_constraints.component_name,
                        context.tree_constraints.template_name
                    )
                        .as_str(),
                ),
            )
            .unwrap();
    }

    // Propagate just one fixed_node.
    fn propagate_fixed_node(
        &mut self,
        fixed_node: SignalIndex,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        if !self.nodes.contains_key(&fixed_node) {
            return;
        }

        // 1. Check if this node is an output signal, and decrement the number of not_yet_fixed
        //      signals if it is

        // The following commented code checks for nodes that have been fixed two times (due
        //  to a bug in the verifier).

        // if !self.nodes.contains_key(&fixed_node) {
        //     println!(
        //         "Component: {}. Template: {}. Fixed_node: {}",
        //         context.tree_constraints.component_name,
        //         context.tree_constraints.template_name,
        //         fixed_node
        //     );
        // }

        if let Node::OutputSignal = self.nodes[&fixed_node] {
            self.number_of_outputs_not_yet_fixed -= 1;
        }

        // 2. Substitute in constraints and propagate fixed_nodes through them

        // 2.1 Safe assignments <==

        if self.outgoing_safe_assignments.contains_key(&fixed_node) {
            for ass_idx in &self.outgoing_safe_assignments[&fixed_node] {
                let ass = &mut self.safe_assignments[*ass_idx];

                if !ass.active {
                    continue;
                }

                let constraint = substitute_witness_signal_into_storage(
                    ass.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );

                // Maybe after substituting an input signal another signal which originally
                //  appeared has now a zero coefficient, so we have to clean that signal too.
                //  Example: out <== -in*inv + 1. If in=0, then it is equivalent to out <== 1
                //  To handle that, instead of just removing from ass.rhs_signals the fixed_node,
                //  we assign to it the new list of signals after simplification

                ass.rhs_signals = constraint.take_cloned_signals_ordered();
                ass.rhs_signals.remove(&ass.lhs_signal);

                // The following comment checks for differences between just removing the fixed
                //  signal and removing all simplified signals as seen above. This can help to
                //  detect bugs where some signals are fixed twice.

                // ass.rhs_signals.remove(&fixed_node);
                // ass.rhs_signals = alternative_signals.clone();
                // if alternative_signals != ass.rhs_signals {
                //     let alternative_vec: Vec<String> = alternative_signals.iter().map(|x| -> String { context.signal_name_map[x].clone() }).collect();
                //     let ass_vec: Vec<String> = ass.rhs_signals.iter().map(|x| -> String { context.signal_name_map[x].clone() }).collect();
                //
                //     println!("Difference found when fixing signal {} in constraint {} in component {} template {}. Alternative: {:?}\n Ass: {:?}",
                //              context.signal_name_map[&fixed_node],
                //              &ass.associated_constraint,
                //              context.tree_constraints.component_name,
                //              context.tree_constraints.template_name,
                //              alternative_vec,
                //              ass_vec);
                // }
                // ass.rhs_signals.remove(&fixed_node);

                propagate_fixed_node_in_safe_assignment(
                    &mut self.fixed_nodes,
                    ass,
                    &mut self.incoming_safe_assignments,
                );
            }

            // Clear all outgoing_safe_assignments for this node
            self.outgoing_safe_assignments.remove(&fixed_node);
        }

        // 2.2 Unsafe constraints ===

        if self.edge_constraints.contains_key(&fixed_node) {
            for unsafe_constraint_idx in &self.edge_constraints[&fixed_node] {
                let unsafe_constraint = &mut self.unsafe_constraints[*unsafe_constraint_idx];

                if !unsafe_constraint.active {
                    continue;
                }

                substitute_witness_signal_into_storage(
                    unsafe_constraint.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );
                unsafe_constraint.signals.remove(&fixed_node);

                propagate_fixed_node_in_unsafe_constraint(
                    constraint_storage,
                    &mut self.fixed_nodes,
                    unsafe_constraint,
                );
            }

            // Clear all edge_constraints for this node
            self.edge_constraints.remove(&fixed_node);
        }

        // 2.3 Sub-components
        if let Node::SubComponentInputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();

            cmp.input_signals.remove(&fixed_node);

            if cmp.input_signals.is_empty() {
                // We have finally fixed_all inputs, we can fix the output and recursively
                // verify the subcomponent
                self.sub_components_to_verify.push(cmp_index);

                for output_signal in &cmp.output_signals {
                    self.fixed_nodes.insert(*output_signal);
                }
            }
        }

        // 3. Remove this node from the graph

        // TODO: Are there any more things to remove apart from the node?

        // If this is an output node, we have to remove it from the outputs of its subcomponent first
        if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
            cmp.output_signals.remove(&fixed_node);
        }

        self.nodes.remove(&fixed_node);
    }
}

// TODO: Study when to apply substitutions. If we want to prove weak safety (only
//  for one input) we could probably apply the substitutions one by one when fixing signals.
//  We need to study the case of strong safety (for all inputs).

//  Substitute the symbolic value of a signal by its witness value on the constraint_storage for a
//   given constraint index.
fn substitute_witness_signal_into_storage(
    constraint_idx: ConstraintIndex,
    context: &InputDataContextView,
    constraint_storage: &mut ConstraintStorage,
    fixed_signal: SignalIndex,
) -> Constraint<usize> {
    let mut constraint = constraint_storage.read_constraint(constraint_idx).unwrap();

    let mut substitution_to_coefficients = HashMap::new();
    substitution_to_coefficients.insert(
        Constraint::constant_coefficient(),
        context.witness[&fixed_signal].clone(),
    );

    let substitution = Substitution::<usize>::new(
        fixed_signal,
        ArithmeticExpression::Linear {
            coefficients: substitution_to_coefficients,
        },
    )
        .unwrap();

    Constraint::apply_substitution(&mut constraint, &substitution, &context.field);

    // Normalize the constraint
    Constraint::fix_constraint(&mut constraint, &context.field);

    constraint_storage.replace(constraint_idx, constraint.clone());

    constraint
}

// This function checks a safe assignment. If all RHS values have been fixed, the LHS will
// also be fixed. Called both on creation of the VerificationGraph and on fixed node propagation
fn propagate_fixed_node_in_safe_assignment(
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    assignment: &mut SafeAssignment,
    incoming_safe_assignments: &mut BTreeMap<SignalIndex, SafeAssignmentIndex>,
) {
    // Fix the LHS of a '<==' assignment if the RHS does not have any signals (are constants)
    if assignment.rhs_signals.is_empty() {
        fixed_nodes.insert(assignment.lhs_signal);

        // Clean up constraint
        incoming_safe_assignments.remove(&assignment.lhs_signal);
        assignment.active = false;
    }
}

// This function checks an unsafe constraint. If it only contains one unfixed signal, the constraint
// is linear and its coefficient is non-zero, that signal will also be marked fixed.
fn propagate_fixed_node_in_unsafe_constraint(
    constraint_storage: &ConstraintStorage,
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    unsafe_constraint: &mut UnsafeConstraint,
) {
    // Fix the only signal of a === constraint if it is the only signal, the constraint is
    // linear, and its coefficient is non-zero

    if unsafe_constraint.signals.len() == 1 {
        let signal = unsafe_constraint.signals.last().unwrap();
        let constraint = constraint_storage
            .read_constraint(unsafe_constraint.associated_constraint)
            .unwrap();

        // TODO: If in the future we want to add support for verifying a subcomponent for all different
        //  inputs, we should check whether we should substitute values into the constraint here.

        if Constraint::<usize>::is_linear(&constraint) {
            // After substituting, the algebra library may remove associated constraints if the
            //  value is 0, so if its not found inside the constraint map, it must be 0

            let zero = BigInt::from(0u32);
            let coefficient = constraint.c().get(signal).unwrap_or(&zero);

            if !coefficient.is_zero() {
                fixed_nodes.insert(*signal);

                // Clean up constraint
                unsafe_constraint.active = false;
            }
        }
    }
}
