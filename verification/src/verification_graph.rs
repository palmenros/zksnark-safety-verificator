use crate::{
    print_verification_graph, ComponentIndex, ConstraintIndex, InputDataContextView, SignalIndex,
};
use circom_algebra::algebra::{ArithmeticExpression, Constraint, Substitution};
use circom_algebra::constraint_storage::ConstraintStorage;
use num_traits::Zero;
use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};
use std::path::Path;

#[allow(clippy::enum_variant_names)]
pub enum Node {
    InputSignal,
    OutputSignal,
    IntermediateSignal,

    SubComponentInputSignal(ComponentIndex),
    SubComponentOutputSignal(ComponentIndex),
}

#[derive(Clone)]
pub struct SafeAssignment {
    // Signal index of the signal appearing in the LHS of the '<==' assignment
    pub lhs_signal: SignalIndex,

    // Signal indices of the signals appearing in the RHS of the '==>' assignment
    pub rhs_signals: BTreeSet<SignalIndex>,

    // Constraint index of the constraint associated to the safe assignment
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A constraint of the type '===' that has not been generated by a safe assignment '<=='
//  TODO: Look for a better name?

#[derive(Clone)]
pub struct UnsafeConstraint {
    // List of *all* participating signals in this constraint, including the key of edge_constraints
    pub signals: BTreeSet<SignalIndex>,

    // Constraint index
    pub associated_constraint: ConstraintIndex,

    // Marks if this assignment is active. To avoid invalidating vector indices, we don't delete
    // assignments from the vector, but we mark them as inactive.
    pub active: bool,
}

// A subcomponent, which has input_signals and output_signals
pub struct SubComponent {
    // input_signals and output_signals are the current inputs and outputs of this component, after
    // possibly removing some nodes by fixed_nodes propagation.
    pub input_signals: BTreeSet<SignalIndex>,
    pub output_signals: BTreeSet<SignalIndex>,

    // original_input_signals and original_output_signals are the original input and output signals
    // of the component, before propagating and possibly removing inputs and outputs
    // TODO: Do we need to store these?
    pub original_input_signals: BTreeSet<SignalIndex>,
    pub original_output_signals: BTreeSet<SignalIndex>,
}

pub type SafeAssignmentIndex = usize;
pub type UnsafeConstraintIndex = usize;

// NOTE: For reproducibility, I have declared the HashMaps as BTreeMap, so they are ordered.
//      Explore whether it's a good idea to change them to HashMap
pub struct VerificationGraph {
    // List of nodes in the graph. Each signal has a node, and it can be of multiple types
    pub nodes: BTreeMap<SignalIndex, Node>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the LHS of the assignment
    pub incoming_safe_assignments: BTreeMap<SignalIndex, SafeAssignmentIndex>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the RHS of the assignment
    pub outgoing_safe_assignments: BTreeMap<SignalIndex, BTreeSet<SafeAssignmentIndex>>,

    // Given a node, it returns the list of all constraints '===' that are not a result of safe
    //    assignments '<==' in which this signal appears
    pub edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>>,

    // Given a component index, it returns the SubComponent struct
    pub subcomponents: BTreeMap<ComponentIndex, SubComponent>,

    // List of all safe_assignments (<==). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub safe_assignments: Vec<SafeAssignment>,

    // List of all unsafe_constraints (===). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub unsafe_constraints: Vec<UnsafeConstraint>,

    //  List of nodes that have been fixed (proved to be unique) but not yet removed from the graph
    pub fixed_nodes: BTreeSet<SignalIndex>,

    // Number of outputs that have not yet been fixed
    pub number_of_outputs_not_yet_fixed: usize,

    // List of subcomponents to verify in order for this component to be verified.
    pub sub_components_to_verify: Vec<ComponentIndex>,
}

impl VerificationGraph {
    pub fn new(
        context: &InputDataContextView,
        constraint_storage: &ConstraintStorage,
    ) -> VerificationGraph {
        let tree_constraints = context.tree_constraints;

        let mut nodes = BTreeMap::<SignalIndex, Node>::new();
        let mut subcomponents = BTreeMap::<ComponentIndex, SubComponent>::new();

        // Outputs
        for idx in 0..tree_constraints.number_outputs {
            let s = idx + tree_constraints.initial_signal;
            nodes.insert(s, Node::OutputSignal);
        }

        let mut input_signals = BTreeSet::new();

        // Inputs
        for idx in 0..tree_constraints.number_inputs {
            let s = idx + tree_constraints.number_outputs + tree_constraints.initial_signal;
            nodes.insert(s, Node::InputSignal);
            input_signals.insert(s);
        }

        // Intermediates
        let number_intermediates = tree_constraints.number_signals
            - tree_constraints.number_outputs
            - tree_constraints.number_inputs;

        for idx in 0..number_intermediates {
            let s = idx
                + tree_constraints.number_outputs
                + tree_constraints.number_inputs
                + tree_constraints.initial_signal;

            nodes.insert(s, Node::IntermediateSignal);
        }

        // Components

        // TODO: We should make a difference between safe and unsafe subcomponents. By default, we will
        //  assume that all subcomponents ought to be safe (that is, their output must remain fixed
        //  if the input is fixed). We should allow "unsafe" subcomponents (such as Inverse), which might
        //  not fully determine their outputs when their inputs are fixed. In that case, we should "extract"
        //  the subcomponent signals, constraints and subcomponents into the parent component, so
        //  we can perform the algorithm taking the relationships into account, not as a black box.
        //      This information about unsafe components should be passed by an input .json

        for (cmp_index, c) in tree_constraints.subcomponents.iter().enumerate() {
            let mut subcomponent_inputs = BTreeSet::new();
            let mut subcomponent_outputs = BTreeSet::new();

            // Subcomponent inputs
            for idx in 0..c.number_inputs {
                let s = idx + c.number_outputs + c.initial_signal;
                subcomponent_inputs.insert(s);
                nodes.insert(s, Node::SubComponentInputSignal(cmp_index));
            }

            for idx in 0..c.number_outputs {
                let s = idx + c.initial_signal;
                subcomponent_outputs.insert(s);

                nodes.insert(s, Node::SubComponentOutputSignal(cmp_index));
            }

            subcomponents.insert(
                cmp_index,
                SubComponent {
                    input_signals: subcomponent_inputs.clone(),
                    output_signals: subcomponent_outputs.clone(),
                    original_input_signals: subcomponent_inputs,
                    original_output_signals: subcomponent_outputs,
                },
            );
        }

        let mut incoming_safe_assignments = BTreeMap::<SignalIndex, SafeAssignmentIndex>::new();
        let mut outgoing_safe_assignments =
            BTreeMap::<SignalIndex, BTreeSet<SafeAssignmentIndex>>::new();
        let mut safe_assignments = vec![];

        let mut is_constraint_double_arrow = HashSet::new();

        // Add safe assignment edges
        for (constraint, lhs_signal) in &tree_constraints.are_double_arrow {
            is_constraint_double_arrow.insert(*constraint);

            let mut signals: BTreeSet<SignalIndex> = constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_cloned_signals_ordered();
            signals.remove(lhs_signal);

            let safe_assignment = SafeAssignment {
                lhs_signal: *lhs_signal,
                rhs_signals: signals,
                associated_constraint: *constraint,
                active: true,
            };

            let safe_assignment_idx = safe_assignments.len();
            safe_assignments.push(safe_assignment);

            incoming_safe_assignments.insert(*lhs_signal, safe_assignment_idx);

            // Outgoings
            for rhs_signal in constraint_storage
                .read_constraint(*constraint)
                .unwrap()
                .take_signals()
            {
                if rhs_signal != lhs_signal {
                    outgoing_safe_assignments
                        .entry(*rhs_signal)
                        .or_insert(BTreeSet::new())
                        .insert(safe_assignment_idx);
                }
            }
        }

        let mut edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>> =
            BTreeMap::new();
        let mut unsafe_constraints: Vec<UnsafeConstraint> = vec![];

        // Add unsafe edges
        let constraints_range = tree_constraints.initial_constraint
            ..(tree_constraints.initial_constraint + tree_constraints.no_constraints);
        for (constraint_index, c) in constraints_range
            .filter(|idx| !is_constraint_double_arrow.contains(idx))
            .map(|x| (x, constraint_storage.read_constraint(x).unwrap()))
        {
            let signals = c.take_cloned_signals_ordered();

            let unsafe_constraint_index = unsafe_constraints.len();

            for &signal in &signals {
                // let vector: BTreeSet<SignalIndex> = signals.iter().filter(|x| **x != signal).copied().collect();
                edge_constraints
                    .entry(signal)
                    .or_insert(BTreeSet::new())
                    .insert(unsafe_constraint_index);
            }

            unsafe_constraints.push(UnsafeConstraint {
                signals,
                associated_constraint: constraint_index,
                active: true,
            });
        }

        // Compute initial fixed_nodes, which should include the inputs, safe assignments of only constants
        //  (for example, i <== 2) and linear constraints with only one appearing signal and non-zero coefficient
        //  (for example, 3*s===1).
        // TODO: Maybe there are more fixed_nodes initial situations to take into account?

        // Input signals
        let mut fixed_nodes = BTreeSet::new();
        fixed_nodes.append(&mut input_signals);

        // TODO: Find if we need to remove the initial fixed_node from any more data structures.
        //  Check the soundness of this initial fixed_nodes assignation

        // Safe assignments of only constants
        for ass in &mut safe_assignments {
            propagate_fixed_node_in_safe_assignment(
                &mut fixed_nodes,
                ass,
                &mut incoming_safe_assignments,
            );
        }

        // Unsafe constraints ===
        for unsafe_constraint in &mut unsafe_constraints {
            propagate_fixed_node_in_unsafe_constraint(
                constraint_storage,
                &mut fixed_nodes,
                unsafe_constraint,
            );
        }

        VerificationGraph {
            nodes,
            incoming_safe_assignments,
            outgoing_safe_assignments,
            edge_constraints,
            subcomponents,
            safe_assignments,
            unsafe_constraints,
            fixed_nodes,
            number_of_outputs_not_yet_fixed: tree_constraints.number_outputs,
            sub_components_to_verify: vec![],
        }
    }

    // This function will propagate the fixed_nodes through the different type of constraints by
    // substituting the fixed value into all the appearing constraints, fixing
    pub fn propagate_fixed_nodes(
        &mut self,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        let mut it_num = 0;
        while !self.fixed_nodes.is_empty() {
            let node = self.fixed_nodes.pop_last().unwrap();
            self.propagate_fixed_node(node, context, constraint_storage);

            // TODO: Remove the following debug print
            let base_path = Path::new(
                r"C:\Users\pedro\Documents\dev\CircomVerification\test-artifacts\binsubtest",
            );

            print_verification_graph(
                self,
                context,
                base_path
                    .join(format!(r"svg/step-{}.svg", it_num))
                    .as_path(),
            )
                .unwrap();

            it_num += 1;
        }
    }

    // Propagate just one fixed_node.
    fn propagate_fixed_node(
        &mut self,
        fixed_node: SignalIndex,
        context: &InputDataContextView,
        constraint_storage: &mut ConstraintStorage,
    ) {
        // 1. Check if this node is an output signal, and decrement the number of not_yet_fixed
        //      signals if it is
        if let Node::OutputSignal = self.nodes[&fixed_node] {
            self.number_of_outputs_not_yet_fixed -= 1;
        }

        assert!(self.incoming_safe_assignments.get(&fixed_node).is_none());

        // TODO: 2. Substitute in constraints and propagate fixed_nodes through them

        // 2.1 Safe assignments <==

        if self.outgoing_safe_assignments.contains_key(&fixed_node) {
            for ass_idx in &self.outgoing_safe_assignments[&fixed_node] {
                let ass = &mut self.safe_assignments[*ass_idx];
                substitute_witness_signal_into_storage(
                    ass.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );
                ass.rhs_signals.remove(&fixed_node);
                propagate_fixed_node_in_safe_assignment(
                    &mut self.fixed_nodes,
                    ass,
                    &mut self.incoming_safe_assignments,
                );
            }

            // Clear all outgoing_safe_assignments for this node
            self.outgoing_safe_assignments.remove(&fixed_node);
        }

        // 2.2 Unsafe constraints ===

        if self.edge_constraints.contains_key(&fixed_node) {
            for unsafe_constraint_idx in &self.edge_constraints[&fixed_node] {
                let unsafe_constraint = &mut self.unsafe_constraints[*unsafe_constraint_idx];
                substitute_witness_signal_into_storage(
                    unsafe_constraint.associated_constraint,
                    context,
                    constraint_storage,
                    fixed_node,
                );
                unsafe_constraint.signals.remove(&fixed_node);

                propagate_fixed_node_in_unsafe_constraint(
                    constraint_storage,
                    &mut self.fixed_nodes,
                    unsafe_constraint,
                );
            }

            // Clear all edge_constraints for this node
            self.edge_constraints.remove(&fixed_node);
        }

        // TODO: 2.3 Sub-components
        if let Node::SubComponentInputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
            cmp.input_signals.remove(&fixed_node);

            if cmp.input_signals.is_empty() {
                // We have finally fixed_all inputs, we can fix the output and recursively
                // verify the subcomponent
                self.sub_components_to_verify.push(cmp_index);

                for output_signal in &cmp.output_signals {
                    self.fixed_nodes.insert(*output_signal);
                }
            }
        }

        // 3. Remove this node from the graph

        // TODO: Are there any more things to remove apart from the node?

        // If this is an output node, we have to remmve it from the outputs of its subcomponent first
        if let Node::SubComponentOutputSignal(cmp_index) = self.nodes[&fixed_node] {
            let cmp = self.subcomponents.get_mut(&cmp_index).unwrap();
            cmp.output_signals.remove(&fixed_node);
        }

        self.nodes.remove(&fixed_node);
    }

    // pub fn get_unsafe_constraints(&self) -> impl Iterator<Item=&UnsafeConstraint> {
    //     self.unsafe_constraints.iter()
    // }
}

// TODO: Study when to apply substitutions. If we want to prove weak safety (only
//  for one input) we could probably apply the substitutions one by one when fixing signals.
//  We need to study the case of strong safety (for all inputs)

//  Substitute the symbolic value of a signal by its witness value on the constraint_storage for a
//   given constraint index.
fn substitute_witness_signal_into_storage(
    constraint_idx: ConstraintIndex,
    context: &InputDataContextView,
    constraint_storage: &mut ConstraintStorage,
    fixed_signal: SignalIndex,
) {
    let mut constraint = constraint_storage.read_constraint(constraint_idx).unwrap();

    let mut substitution_to_coefficients = HashMap::new();
    substitution_to_coefficients.insert(
        Constraint::constant_coefficient(),
        context.witness[&fixed_signal].clone(),
    );

    let substitution = Substitution::<usize>::new(
        fixed_signal,
        ArithmeticExpression::Linear {
            coefficients: substitution_to_coefficients,
        },
    )
        .unwrap();

    Constraint::apply_substitution(&mut constraint, &substitution, &context.field);

    // TODO: Check that we are doing a correct normalization
    Constraint::fix_constraint(&mut constraint, &context.field);

    constraint_storage.replace(constraint_idx, constraint);
}

// This function checks a safe assignment. If all RHS values have been fixed, the LHS will
// also be fixed. Called both on creation of the VerificationGraph and on fixed node propagation
fn propagate_fixed_node_in_safe_assignment(
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    assignment: &mut SafeAssignment,
    incoming_safe_assignments: &mut BTreeMap<SignalIndex, SafeAssignmentIndex>,
) {
    // Fix the LHS of a '<==' assignment if the RHS does not have any signals (are constants)
    // TODO: Is this condition correct and complete for safe assignments?
    if assignment.rhs_signals.is_empty() {
        fixed_nodes.insert(assignment.lhs_signal);

        // Clean up constraint
        incoming_safe_assignments.remove(&assignment.lhs_signal);
        assignment.active = false;
    }
}

// This function checks an unsafe constraint. If it only contains one unfixed signal, the constraint
// is linear and its coefficient is non-zero, that signal will also be marked fixed.
fn propagate_fixed_node_in_unsafe_constraint(
    constraint_storage: &ConstraintStorage,
    fixed_nodes: &mut BTreeSet<SignalIndex>,
    unsafe_constraint: &mut UnsafeConstraint,
) {
    // Fix the only signal of a === constraint if it is the only signal, the constraint is
    // linear, and its coefficient is non-zero
    // TODO: Is this condition correct and complete for unsafe assignments?

    if unsafe_constraint.signals.len() == 1 {
        let signal = unsafe_constraint.signals.last().unwrap();
        let constraint = constraint_storage
            .read_constraint(unsafe_constraint.associated_constraint)
            .unwrap();

        // TODO: If in the future we want to add support for verifying a subcomponent for all different
        //  inputs, we should check whether we should substitute values into the constraint here.

        // TODO: Check if this is the correct form to compute whether the constraint is linear
        if Constraint::<usize>::is_linear(&constraint) {
            let coefficient = constraint.c().get(signal).unwrap();
            if !coefficient.is_zero() {
                fixed_nodes.insert(*signal);

                // Clean up constraint
                unsafe_constraint.active = false;
            }
        }
    }
}
