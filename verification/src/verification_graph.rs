use std::collections::{btree_map, BTreeMap, BTreeSet, HashSet};
use crate::{ComponentIndex, ConstraintIndex, InputDataContext, SignalIndex, TreeConstraints};

pub struct SubComponentOutputNode {
    // Component index
    component: ComponentIndex,

    // Inputs from this component that have not been fixed yet
    not_yet_fixed_inputs: Vec<SignalIndex>,
}

pub enum Node {
    InputSignal,
    OutputSignal,
    IntermediateSignal,

    SubComponentInputSignal(ComponentIndex),
    SubComponentOutputSignal(SubComponentOutputNode),
}

// TODO: Create a counterpart for SafeAssignment for components
#[derive(Clone)]
pub struct SafeAssignment {
    // Signal index of the signal appearing in the LHS of the '<==' assignment
    lhs_signal: SignalIndex,

    // Signal indices of the signals appearing in the RHS of the '==>' assignment
    rhs_signals: BTreeSet<SignalIndex>,

    // Constraint index of the constraint associated to the safe assignment
    associated_constraint: ConstraintIndex,
}

// A constraint of the type '===' that has not been generated by a safe assignment '<=='
//  TODO: Look for a better name
pub struct UnsafeConstraint {
    // List of participating signals in this constraint
    signals: BTreeSet<SignalIndex>,

    // Constraint index
    associated_constraint: ConstraintIndex,
}

// A subcomponent, which has input_signals and output_signals
pub struct SubComponent {
    input_signals: Vec<SignalIndex>,
    output_signals: Vec<SignalIndex>,
}

// NOTE: For reproducibility, I have declared the HashMaps as BTreeMap, so they are ordered.
//      Explore whether it's a good idea to change them to HashMap
pub struct VerificationGraph {
    // List of nodes in the graph. Each signal has a node, and it can be of multiple types
    nodes: BTreeMap<SignalIndex, Node>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the LHS of the assignment
    incoming_safe_assignments: BTreeMap<SignalIndex, SafeAssignment>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the RHS of the assignment
    outgoing_safe_assignments: BTreeMap<SignalIndex, Vec<SafeAssignment>>,

    // Given a node, it returns the list of all constraints '===' that are not a result of safe
    //    assignments '<==' in which this signal appears
    edge_constraints: BTreeMap<SignalIndex, Vec<UnsafeConstraint>>,

    // Given a component index, it returns the SubComponent struct
    subcomponents: BTreeMap<ComponentIndex, SubComponent>,

    //  List of nodes that have been fixed (proved to be unique) but not yet removed?
    fixed_nodes: BTreeSet<SignalIndex>,
}


impl VerificationGraph {
    pub fn create(
        context: &InputDataContext,
    ) -> VerificationGraph {
        let tree_constraints = &context.tree_constraints;

        let mut nodes = BTreeMap::<SignalIndex, Node>::new();
        let mut subcomponents = BTreeMap::<ComponentIndex, SubComponent>::new();

        // Outputs
        for idx in 0..tree_constraints.number_outputs {
            let s = idx + tree_constraints.initial_signal;
            nodes.insert(
                s, Node::OutputSignal,
            );
        }

        // Inputs
        for idx in 0..tree_constraints.number_inputs {
            let s = idx + tree_constraints.number_outputs + tree_constraints.initial_signal;
            nodes.insert(
                s, Node::InputSignal,
            );
        }

        // Intermediates
        let number_intermediates = tree_constraints.number_signals - tree_constraints.number_outputs
            - tree_constraints.number_inputs;

        for idx in 0..number_intermediates {
            let s = idx
                + tree_constraints.number_outputs
                + tree_constraints.number_inputs
                + tree_constraints.initial_signal;

            nodes.insert(s, Node::IntermediateSignal);
        }

        // Components
        for c in &tree_constraints.subcomponents {
            let mut subcomponent_inputs = vec![];
            let mut subcomponent_outputs = vec![];
            let component_index = c.node_id;

            // Subcomponent inputs
            for idx in 0..c.number_inputs {
                let s = idx + c.number_outputs + c.initial_signal;
                subcomponent_inputs.push(s);
                nodes.insert(
                    s, Node::SubComponentInputSignal(component_index),
                );
            }

            // Subcomponent outputs
            for idx in 0..c.number_outputs {
                let s = idx + c.initial_signal;
                subcomponent_outputs.push(s);

                let sub_component_output_node = SubComponentOutputNode {
                    component: c.node_id,
                    not_yet_fixed_inputs: subcomponent_inputs.clone(),
                };

                nodes.insert(
                    s, Node::SubComponentOutputSignal(sub_component_output_node),
                );
            }

            subcomponents.insert(
                c.node_id,
                SubComponent { input_signals: subcomponent_inputs, output_signals: subcomponent_outputs },
            );
        }

        let mut incoming_safe_assignments = BTreeMap::<SignalIndex, SafeAssignment>::new();
        let mut outgoing_safe_assignments = BTreeMap::<SignalIndex, Vec<SafeAssignment>>::new();

        let mut is_constraint_double_arrow = HashSet::new();

        // Add safe assignment edges
        for (constraint, lhs_signal) in &tree_constraints.are_double_arrow {
            is_constraint_double_arrow.insert(*constraint);

            //  TODO: Optimize. Avoid conversion from HashSet to BTreeSet
            let mut signals: BTreeSet<SignalIndex> = context.constraint_storage.read_constraint(*constraint).unwrap().take_cloned_signals_ordered();
            signals.remove(lhs_signal);

            let safe_assignment = SafeAssignment {
                lhs_signal: *lhs_signal,
                rhs_signals: signals,
                associated_constraint: *constraint,
            };

            incoming_safe_assignments.insert(*lhs_signal, safe_assignment.clone());

            // Outgoings
            for rhs_signal in context.constraint_storage.read_constraint(*constraint).unwrap().take_signals() {
                if rhs_signal != lhs_signal {
                    outgoing_safe_assignments.entry(*rhs_signal).or_insert(vec![]).push(safe_assignment.clone());
                }
            }
        }

        let mut edge_constraints: BTreeMap<SignalIndex, Vec<UnsafeConstraint>> = BTreeMap::new();

        // Add unsafe edges
        let constraints_range = tree_constraints.initial_constraint..(tree_constraints.initial_constraint + tree_constraints.no_constraints);
        for (constraint_index, c) in constraints_range.filter(|idx| is_constraint_double_arrow.contains(idx))
            .map(|x| (x, context.constraint_storage.read_constraint(x).unwrap())) {
            let signals = c.take_cloned_signals_ordered();

            for &signal in &signals {
                let vector: BTreeSet<SignalIndex> = signals.iter().filter(|x| **x != signal).copied().collect();
                edge_constraints.entry(signal).or_insert(vec![]).push(UnsafeConstraint {
                    signals: vector,
                    associated_constraint: constraint_index,
                });
            }
        }

        VerificationGraph {
            nodes,
            incoming_safe_assignments,
            outgoing_safe_assignments,
            edge_constraints,
            subcomponents,
            fixed_nodes: BTreeSet::new(),
        }
    }

    // TODO: See how to return an iterator from a method (lifetime annotations).
    // pub fn nodes(self) -> btree_map::Values<'_, usize, Node> {
    //     self.nodes.values()
    // }
}