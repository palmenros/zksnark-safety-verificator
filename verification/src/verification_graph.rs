use std::collections::{BTreeMap, BTreeSet, HashSet};
use crate::{ComponentIndex, ConstraintIndex, InputDataContextView, SignalIndex};

#[allow(clippy::enum_variant_names)]
pub enum Node {
    InputSignal,
    OutputSignal,
    IntermediateSignal,

    SubComponentInputSignal(ComponentIndex),
    SubComponentOutputSignal(ComponentIndex),
}

// TODO: Create a counterpart for SafeAssignment for components
#[derive(Clone)]
pub struct SafeAssignment {
    // Signal index of the signal appearing in the LHS of the '<==' assignment
    pub lhs_signal: SignalIndex,

    // Signal indices of the signals appearing in the RHS of the '==>' assignment
    pub rhs_signals: BTreeSet<SignalIndex>,

    // Constraint index of the constraint associated to the safe assignment
    pub associated_constraint: ConstraintIndex,
}

// A constraint of the type '===' that has not been generated by a safe assignment '<=='
//  TODO: Look for a better name

#[derive(Clone)]
pub struct UnsafeConstraint {
    // List of *all* participating signals in this constraint, including the key of edge_constraints
    pub signals: BTreeSet<SignalIndex>,

    // Constraint index
    pub associated_constraint: ConstraintIndex,
}

// A subcomponent, which has input_signals and output_signals
pub struct SubComponent {
    pub input_signals: BTreeSet<SignalIndex>,
    pub output_signals: BTreeSet<SignalIndex>,

    pub not_yet_fixed_inputs: BTreeSet<SignalIndex>,
}

pub type SafeAssignmentIndex = usize;
pub type UnsafeConstraintIndex = usize;

// NOTE: For reproducibility, I have declared the HashMaps as BTreeMap, so they are ordered.
//      Explore whether it's a good idea to change them to HashMap
pub struct VerificationGraph {
    // List of nodes in the graph. Each signal has a node, and it can be of multiple types
    pub nodes: BTreeMap<SignalIndex, Node>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the LHS of the assignment
    pub incoming_safe_assignments: BTreeMap<SignalIndex, SafeAssignmentIndex>,

    // Given a node, it returns the list of safe assignments '<==' in which this signal is part of
    //    the RHS of the assignment
    pub outgoing_safe_assignments: BTreeMap<SignalIndex, BTreeSet<SafeAssignmentIndex>>,
    
    // Given a node, it returns the list of all constraints '===' that are not a result of safe
    //    assignments '<==' in which this signal appears
    pub edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>>,

    // Given a component index, it returns the SubComponent struct
    pub subcomponents: BTreeMap<ComponentIndex, SubComponent>,

    // List of all safe_assignments (<==). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub safe_assignments: Vec<SafeAssignment>,

    // List of all unsafe_constraints (===). Edges only have indices into this vector.
    // Elements in this vector should not be removed, because the indices would be invalidated.
    pub unsafe_constraints: Vec<UnsafeConstraint>,

    //  List of nodes that have been fixed (proved to be unique) but not yet removed from the graph
    pub fixed_nodes: BTreeSet<SignalIndex>,
}


impl VerificationGraph {
    pub fn create(
        context: &InputDataContextView,
    ) -> VerificationGraph {
        let tree_constraints = context.tree_constraints;

        let mut nodes = BTreeMap::<SignalIndex, Node>::new();
        let mut subcomponents = BTreeMap::<ComponentIndex, SubComponent>::new();

        // Outputs
        for idx in 0..tree_constraints.number_outputs {
            let s = idx + tree_constraints.initial_signal;
            nodes.insert(
                s, Node::OutputSignal,
            );
        }

        // Inputs
        for idx in 0..tree_constraints.number_inputs {
            let s = idx + tree_constraints.number_outputs + tree_constraints.initial_signal;
            nodes.insert(
                s, Node::InputSignal,
            );
        }

        // Intermediates
        let number_intermediates = tree_constraints.number_signals - tree_constraints.number_outputs
            - tree_constraints.number_inputs;

        for idx in 0..number_intermediates {
            let s = idx
                + tree_constraints.number_outputs
                + tree_constraints.number_inputs
                + tree_constraints.initial_signal;

            nodes.insert(s, Node::IntermediateSignal);
        }

        // Components
        for (cmp_index, c) in tree_constraints.subcomponents.iter().enumerate() {
            let mut subcomponent_inputs = BTreeSet::new();
            let mut subcomponent_outputs = BTreeSet::new();
            let component_index = c.node_id;

            // Subcomponent inputs
            for idx in 0..c.number_inputs {
                let s = idx + c.number_outputs + c.initial_signal;
                subcomponent_inputs.insert(s);
                nodes.insert(
                    s, Node::SubComponentInputSignal(component_index),
                );
            }

            // Subcomponent outputs
            for idx in 0..c.number_outputs {
                let s = idx + c.initial_signal;
                subcomponent_outputs.insert(s);

                nodes.insert(
                    s, Node::SubComponentOutputSignal(cmp_index),
                );
            }

            subcomponents.insert(
                cmp_index,
                SubComponent {
                    input_signals: subcomponent_inputs.clone(),
                    output_signals: subcomponent_outputs,
                    not_yet_fixed_inputs: subcomponent_inputs,
                },
            );
        }

        let mut incoming_safe_assignments = BTreeMap::<SignalIndex, SafeAssignmentIndex>::new();
        let mut outgoing_safe_assignments = BTreeMap::<SignalIndex, BTreeSet<SafeAssignmentIndex>>::new();
        let mut safe_assignments = vec![];

        let mut is_constraint_double_arrow = HashSet::new();

        // Add safe assignment edges
        for (constraint, lhs_signal) in &tree_constraints.are_double_arrow {
            is_constraint_double_arrow.insert(*constraint);

            //  TODO: Optimize. Avoid conversion from HashSet to BTreeSet
            let mut signals: BTreeSet<SignalIndex> = context.constraint_storage.read_constraint(*constraint).unwrap().take_cloned_signals_ordered();
            signals.remove(lhs_signal);

            let safe_assignment = SafeAssignment {
                lhs_signal: *lhs_signal,
                rhs_signals: signals,
                associated_constraint: *constraint,
            };

            let safe_assignment_idx = safe_assignments.len();
            safe_assignments.push(safe_assignment);

            incoming_safe_assignments.insert(*lhs_signal, safe_assignment_idx);

            // Outgoings
            for rhs_signal in context.constraint_storage.read_constraint(*constraint).unwrap().take_signals() {
                if rhs_signal != lhs_signal {
                    outgoing_safe_assignments.entry(*rhs_signal).or_insert(BTreeSet::new()).insert(safe_assignment_idx);
                }
            }
        }

        let mut edge_constraints: BTreeMap<SignalIndex, BTreeSet<UnsafeConstraintIndex>> = BTreeMap::new();
        let mut unsafe_constraints: Vec<UnsafeConstraint> = vec![];

        // Add unsafe edges
        let constraints_range = tree_constraints.initial_constraint..(tree_constraints.initial_constraint + tree_constraints.no_constraints);
        for (constraint_index, c) in constraints_range.filter(|idx| !is_constraint_double_arrow.contains(idx))
            .map(|x| (x, context.constraint_storage.read_constraint(x).unwrap())) {
            let signals = c.take_cloned_signals_ordered();

            let unsafe_constraint_index = unsafe_constraints.len();

            for &signal in &signals {
                // let vector: BTreeSet<SignalIndex> = signals.iter().filter(|x| **x != signal).copied().collect();
                edge_constraints.entry(signal).or_insert(BTreeSet::new()).insert(unsafe_constraint_index);
            }

            unsafe_constraints.push(UnsafeConstraint {
                signals,
                associated_constraint: constraint_index,
            });
        }

        // TODO: Compute fixed_nodes, which should include the inputs, safe assignments of only constants
        //  (for example, i <== 2) and linear constraints with only one appearing signal and non-zero coefficient
        //  (for example, 3*s===1). Maybe there are more to take into account?

        VerificationGraph {
            nodes,
            incoming_safe_assignments,
            outgoing_safe_assignments,
            edge_constraints,
            subcomponents,
            safe_assignments,
            unsafe_constraints,
            fixed_nodes: BTreeSet::new(),
        }
    }

    // pub fn get_unsafe_constraints(&self) -> impl Iterator<Item=&UnsafeConstraint> {
    //     self.unsafe_constraints.iter()
    // }
}